/* tslint:disable */
/* eslint-disable */
/**
 * InRussianBackend API
 * API для проекта InRussian, которое используется для /домен вебсайта/ и приложения InRussian для Android и iOS.
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminCreatedResponse
 */
export interface AdminCreatedResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AdminCreatedResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof AdminCreatedResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreatedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof AdminCreatedResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface Badge
 */
export interface Badge {
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'iconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'badgeType': BadgeBadgeTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof Badge
     */
    'criteria'?: object;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'createdAt': string;
}

export const BadgeBadgeTypeEnum = {
    CourseCompletion: 'COURSE_COMPLETION',
    ThemeCompletion: 'THEME_COMPLETION',
    Streak: 'STREAK',
    Achievement: 'ACHIEVEMENT'
} as const;

export type BadgeBadgeTypeEnum = typeof BadgeBadgeTypeEnum[keyof typeof BadgeBadgeTypeEnum];

/**
 * 
 * @export
 * @interface CountStats
 */
export interface CountStats {
    /**
     * 
     * @type {number}
     * @memberof CountStats
     */
    'coursesCount': number;
    /**
     * 
     * @type {number}
     * @memberof CountStats
     */
    'sectionsCount': number;
    /**
     * 
     * @type {number}
     * @memberof CountStats
     */
    'themesCount': number;
    /**
     * 
     * @type {number}
     * @memberof CountStats
     */
    'tasksCount': number;
}
/**
 * 
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'authorUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof Course
     */
    'isPublished': boolean;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CourseProgressItem
 */
export interface CourseProgressItem {
    /**
     * 
     * @type {string}
     * @memberof CourseProgressItem
     */
    'courseId': string;
    /**
     * 
     * @type {number}
     * @memberof CourseProgressItem
     */
    'totalTasks': number;
    /**
     * 
     * @type {number}
     * @memberof CourseProgressItem
     */
    'completedTasks': number;
    /**
     * 
     * @type {object}
     * @memberof CourseProgressItem
     */
    'progressPercentage': object;
    /**
     * 
     * @type {Array<SectionProgressItem>}
     * @memberof CourseProgressItem
     */
    'sectionsProgress': Array<SectionProgressItem>;
}
/**
 * 
 * @export
 * @interface CreateCourseRequest
 */
export interface CreateCourseRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequest
     */
    'authorUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequest
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCourseRequest
     */
    'isPublished': boolean;
}
/**
 * 
 * @export
 * @interface CreateReportRequest
 */
export interface CreateReportRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateReportRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateReportRequest
     */
    'taskId': string;
}
/**
 * 
 * @export
 * @interface CreateSectionRequest
 */
export interface CreateSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateSectionRequest
     */
    'courseId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSectionRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSectionRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateSectionRequest
     */
    'orderNum': number;
}
/**
 * 
 * @export
 * @interface CreateStaffProfileRequest
 */
export interface CreateStaffProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateStaffProfileRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateStaffProfileRequest
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateStaffProfileRequest
     */
    'patronymic'?: string;
}
/**
 * 
 * @export
 * @interface CreateTaskAnswerOptionRequest
 */
export interface CreateTaskAnswerOptionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskAnswerOptionRequest
     */
    'optionText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskAnswerOptionRequest
     */
    'optionAudioId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTaskAnswerOptionRequest
     */
    'isCorrect': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateTaskAnswerOptionRequest
     */
    'orderNum': number;
}
/**
 * 
 * @export
 * @interface CreateTaskAnswerRequest
 */
export interface CreateTaskAnswerRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskAnswerRequest
     */
    'answerType': CreateTaskAnswerRequestAnswerTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof CreateTaskAnswerRequest
     */
    'correctAnswer': object;
}

export const CreateTaskAnswerRequestAnswerTypeEnum = {
    MultipleChoiceShort: 'MULTIPLE_CHOICE_SHORT',
    MultipleChoiceLong: 'MULTIPLE_CHOICE_LONG',
    SingleChoiceShort: 'SINGLE_CHOICE_SHORT',
    SingleChoiceLong: 'SINGLE_CHOICE_LONG',
    TextInput: 'TEXT_INPUT',
    WordOrder: 'WORD_ORDER',
    WordSelection: 'WORD_SELECTION'
} as const;

export type CreateTaskAnswerRequestAnswerTypeEnum = typeof CreateTaskAnswerRequestAnswerTypeEnum[keyof typeof CreateTaskAnswerRequestAnswerTypeEnum];

/**
 * 
 * @export
 * @interface CreateTaskContentRequest
 */
export interface CreateTaskContentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskContentRequest
     */
    'contentType': CreateTaskContentRequestContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskContentRequest
     */
    'contentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskContentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskContentRequest
     */
    'transcription'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskContentRequest
     */
    'translation'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTaskContentRequest
     */
    'orderNum': number;
}

export const CreateTaskContentRequestContentTypeEnum = {
    Audio: 'AUDIO',
    Image: 'IMAGE',
    Text: 'TEXT',
    Video: 'VIDEO'
} as const;

export type CreateTaskContentRequestContentTypeEnum = typeof CreateTaskContentRequestContentTypeEnum[keyof typeof CreateTaskContentRequestContentTypeEnum];

/**
 * 
 * @export
 * @interface CreateTaskQueueRequest
 */
export interface CreateTaskQueueRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskQueueRequest
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskQueueRequest
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskQueueRequest
     */
    'themeId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskQueueRequest
     */
    'sectionId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTaskQueueRequest
     */
    'queuePosition': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTaskQueueRequest
     */
    'isOriginalTask': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTaskQueueRequest
     */
    'isRetryTask': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskQueueRequest
     */
    'originalTaskId'?: string;
}
/**
 * 
 * @export
 * @interface CreateTaskRequest
 */
export interface CreateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'themeId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'taskType': CreateTaskRequestTaskTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'instructions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTaskRequest
     */
    'isTraining': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateTaskRequest
     */
    'orderNum': number;
}

export const CreateTaskRequestTaskTypeEnum = {
    ListenAndChoose: 'LISTEN_AND_CHOOSE',
    ReadAndChoose: 'READ_AND_CHOOSE',
    LookAndChoose: 'LOOK_AND_CHOOSE',
    MatchAudioText: 'MATCH_AUDIO_TEXT',
    MatchTextText: 'MATCH_TEXT_TEXT'
} as const;

export type CreateTaskRequestTaskTypeEnum = typeof CreateTaskRequestTaskTypeEnum[keyof typeof CreateTaskRequestTaskTypeEnum];

/**
 * 
 * @export
 * @interface CreateThemeRequest
 */
export interface CreateThemeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateThemeRequest
     */
    'sectionId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateThemeRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateThemeRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateThemeRequest
     */
    'orderNum': number;
}
/**
 * 
 * @export
 * @interface CreateUserProfileRequest
 */
export interface CreateUserProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'patronymic'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'gender': CreateUserProfileRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'dob': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'dor': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'citizenship'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'countryOfResidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'cityOfResidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'countryDuringEducation'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'periodSpent'?: CreateUserProfileRequestPeriodSpentEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'kindOfActivity'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'education'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'purposeOfRegister'?: string;
}

export const CreateUserProfileRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type CreateUserProfileRequestGenderEnum = typeof CreateUserProfileRequestGenderEnum[keyof typeof CreateUserProfileRequestGenderEnum];
export const CreateUserProfileRequestPeriodSpentEnum = {
    MonthMinus: 'MONTH_MINUS',
    MonthSixMonthsMinus: 'MONTH_SIX_MONTHS_MINUS',
    SixMonths: 'SIX_MONTHS',
    YearMinus: 'YEAR_MINUS',
    YearYearPlus: 'YEAR_YEAR_PLUS',
    YearPlus: 'YEAR_PLUS',
    FiveYearPlus: 'FIVE_YEAR_PLUS',
    FiveYearsPlus: 'FIVE_YEARS_PLUS',
    Never: 'NEVER'
} as const;

export type CreateUserProfileRequestPeriodSpentEnum = typeof CreateUserProfileRequestPeriodSpentEnum[keyof typeof CreateUserProfileRequestPeriodSpentEnum];

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'code'?: number;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {UserInfo}
     * @memberof LoginResponse
     */
    'user': UserInfo;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface MediaFileMeta
 */
export interface MediaFileMeta {
    /**
     * 
     * @type {string}
     * @memberof MediaFileMeta
     */
    'mediaId': string;
    /**
     * 
     * @type {string}
     * @memberof MediaFileMeta
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof MediaFileMeta
     */
    'mimeType': string;
    /**
     * 
     * @type {number}
     * @memberof MediaFileMeta
     */
    'fileSize': number;
    /**
     * 
     * @type {string}
     * @memberof MediaFileMeta
     */
    'fileType': MediaFileMetaFileTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MediaFileMeta
     */
    'uploadedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaFileMeta
     */
    'uploadedAt': string;
}

export const MediaFileMetaFileTypeEnum = {
    Image: 'IMAGE',
    Audio: 'AUDIO',
    Video: 'VIDEO',
    Avatar: 'AVATAR'
} as const;

export type MediaFileMetaFileTypeEnum = typeof MediaFileMetaFileTypeEnum[keyof typeof MediaFileMetaFileTypeEnum];

/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * 
     * @type {boolean}
     * @memberof MessageResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'reporterId': string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface Section
 */
export interface Section {
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'courseId': string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Section
     */
    'orderNum': number;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface SectionProgressItem
 */
export interface SectionProgressItem {
    /**
     * 
     * @type {string}
     * @memberof SectionProgressItem
     */
    'sectionId': string;
    /**
     * 
     * @type {number}
     * @memberof SectionProgressItem
     */
    'totalTasks': number;
    /**
     * 
     * @type {number}
     * @memberof SectionProgressItem
     */
    'completedTasks': number;
    /**
     * 
     * @type {object}
     * @memberof SectionProgressItem
     */
    'progressPercentage': object;
}
/**
 * 
 * @export
 * @interface StaffProfile
 */
export interface StaffProfile {
    /**
     * 
     * @type {string}
     * @memberof StaffProfile
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof StaffProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StaffProfile
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof StaffProfile
     */
    'patronymic'?: string;
}
/**
 * 
 * @export
 * @interface StaffProfileResponse
 */
export interface StaffProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof StaffProfileResponse
     */
    'success': boolean;
    /**
     * 
     * @type {StaffProfile}
     * @memberof StaffProfileResponse
     */
    'profile': StaffProfile;
    /**
     * 
     * @type {string}
     * @memberof StaffProfileResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof StaffProfileResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface StaffRegisterRequest
 */
export interface StaffRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffRegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof StaffRegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof StaffRegisterRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof StaffRegisterRequest
     */
    'role': StaffRegisterRequestRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof StaffRegisterRequest
     */
    'systemLanguage': StaffRegisterRequestSystemLanguageEnum;
}

export const StaffRegisterRequestRoleEnum = {
    Student: 'STUDENT',
    Expert: 'EXPERT',
    ContentModerator: 'CONTENT_MODERATOR',
    Admin: 'ADMIN'
} as const;

export type StaffRegisterRequestRoleEnum = typeof StaffRegisterRequestRoleEnum[keyof typeof StaffRegisterRequestRoleEnum];
export const StaffRegisterRequestSystemLanguageEnum = {
    Russian: 'RUSSIAN',
    Uzbek: 'UZBEK',
    Chinese: 'CHINESE',
    Hindi: 'HINDI',
    Tajik: 'TAJIK',
    English: 'ENGLISH'
} as const;

export type StaffRegisterRequestSystemLanguageEnum = typeof StaffRegisterRequestSystemLanguageEnum[keyof typeof StaffRegisterRequestSystemLanguageEnum];

/**
 * 
 * @export
 * @interface StudentRegisterRequest
 */
export interface StudentRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof StudentRegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof StudentRegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof StudentRegisterRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentRegisterRequest
     */
    'systemLanguage': StudentRegisterRequestSystemLanguageEnum;
}

export const StudentRegisterRequestSystemLanguageEnum = {
    Russian: 'RUSSIAN',
    Uzbek: 'UZBEK',
    Chinese: 'CHINESE',
    Hindi: 'HINDI',
    Tajik: 'TAJIK',
    English: 'ENGLISH'
} as const;

export type StudentRegisterRequestSystemLanguageEnum = typeof StudentRegisterRequestSystemLanguageEnum[keyof typeof StudentRegisterRequestSystemLanguageEnum];

/**
 * 
 * @export
 * @interface TaskAnswerItem
 */
export interface TaskAnswerItem {
    /**
     * 
     * @type {string}
     * @memberof TaskAnswerItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskAnswerItem
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskAnswerItem
     */
    'answerType': TaskAnswerItemAnswerTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof TaskAnswerItem
     */
    'correctAnswer': object;
}

export const TaskAnswerItemAnswerTypeEnum = {
    MultipleChoiceShort: 'MULTIPLE_CHOICE_SHORT',
    MultipleChoiceLong: 'MULTIPLE_CHOICE_LONG',
    SingleChoiceShort: 'SINGLE_CHOICE_SHORT',
    SingleChoiceLong: 'SINGLE_CHOICE_LONG',
    TextInput: 'TEXT_INPUT',
    WordOrder: 'WORD_ORDER',
    WordSelection: 'WORD_SELECTION'
} as const;

export type TaskAnswerItemAnswerTypeEnum = typeof TaskAnswerItemAnswerTypeEnum[keyof typeof TaskAnswerItemAnswerTypeEnum];

/**
 * 
 * @export
 * @interface TaskAnswerOptionItem
 */
export interface TaskAnswerOptionItem {
    /**
     * 
     * @type {string}
     * @memberof TaskAnswerOptionItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskAnswerOptionItem
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskAnswerOptionItem
     */
    'optionText'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskAnswerOptionItem
     */
    'optionAudioId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskAnswerOptionItem
     */
    'isCorrect': boolean;
    /**
     * 
     * @type {number}
     * @memberof TaskAnswerOptionItem
     */
    'orderNum': number;
}
/**
 * 
 * @export
 * @interface TaskContentItem
 */
export interface TaskContentItem {
    /**
     * 
     * @type {string}
     * @memberof TaskContentItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskContentItem
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskContentItem
     */
    'contentType': TaskContentItemContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TaskContentItem
     */
    'contentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskContentItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskContentItem
     */
    'transcription'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskContentItem
     */
    'translation'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskContentItem
     */
    'orderNum': number;
}

export const TaskContentItemContentTypeEnum = {
    Audio: 'AUDIO',
    Image: 'IMAGE',
    Text: 'TEXT',
    Video: 'VIDEO'
} as const;

export type TaskContentItemContentTypeEnum = typeof TaskContentItemContentTypeEnum[keyof typeof TaskContentItemContentTypeEnum];

/**
 * 
 * @export
 * @interface TaskWithDetails
 */
export interface TaskWithDetails {
    /**
     * 
     * @type {string}
     * @memberof TaskWithDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskWithDetails
     */
    'themeId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskWithDetails
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TaskWithDetails
     */
    'taskType': TaskWithDetailsTaskTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TaskWithDetails
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof TaskWithDetails
     */
    'instructions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskWithDetails
     */
    'isTraining': boolean;
    /**
     * 
     * @type {number}
     * @memberof TaskWithDetails
     */
    'orderNum': number;
    /**
     * 
     * @type {string}
     * @memberof TaskWithDetails
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<TaskContentItem>}
     * @memberof TaskWithDetails
     */
    'content': Array<TaskContentItem>;
    /**
     * 
     * @type {TaskAnswerItem}
     * @memberof TaskWithDetails
     */
    'answer'?: TaskAnswerItem;
    /**
     * 
     * @type {Array<TaskAnswerOptionItem>}
     * @memberof TaskWithDetails
     */
    'answerOptions': Array<TaskAnswerOptionItem>;
}

export const TaskWithDetailsTaskTypeEnum = {
    ListenAndChoose: 'LISTEN_AND_CHOOSE',
    ReadAndChoose: 'READ_AND_CHOOSE',
    LookAndChoose: 'LOOK_AND_CHOOSE',
    MatchAudioText: 'MATCH_AUDIO_TEXT',
    MatchTextText: 'MATCH_TEXT_TEXT'
} as const;

export type TaskWithDetailsTaskTypeEnum = typeof TaskWithDetailsTaskTypeEnum[keyof typeof TaskWithDetailsTaskTypeEnum];

/**
 * 
 * @export
 * @interface Theme
 */
export interface Theme {
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'sectionId': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Theme
     */
    'orderNum': number;
    /**
     * 
     * @type {string}
     * @memberof Theme
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface UpdateCourseRequest
 */
export interface UpdateCourseRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequest
     */
    'authorUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequest
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCourseRequest
     */
    'isPublished'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateSectionRequest
 */
export interface UpdateSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSectionRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSectionRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateSectionRequest
     */
    'orderNum'?: number;
}
/**
 * 
 * @export
 * @interface UpdateStaffProfileRequest
 */
export interface UpdateStaffProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateStaffProfileRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStaffProfileRequest
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStaffProfileRequest
     */
    'patronymic'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTaskAnswerOptionRequest
 */
export interface UpdateTaskAnswerOptionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskAnswerOptionRequest
     */
    'optionText'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskAnswerOptionRequest
     */
    'optionAudioId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTaskAnswerOptionRequest
     */
    'isCorrect'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateTaskAnswerOptionRequest
     */
    'orderNum'?: number;
}
/**
 * 
 * @export
 * @interface UpdateTaskAnswerRequest
 */
export interface UpdateTaskAnswerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskAnswerRequest
     */
    'answerType'?: UpdateTaskAnswerRequestAnswerTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof UpdateTaskAnswerRequest
     */
    'correctAnswer'?: object;
}

export const UpdateTaskAnswerRequestAnswerTypeEnum = {
    MultipleChoiceShort: 'MULTIPLE_CHOICE_SHORT',
    MultipleChoiceLong: 'MULTIPLE_CHOICE_LONG',
    SingleChoiceShort: 'SINGLE_CHOICE_SHORT',
    SingleChoiceLong: 'SINGLE_CHOICE_LONG',
    TextInput: 'TEXT_INPUT',
    WordOrder: 'WORD_ORDER',
    WordSelection: 'WORD_SELECTION'
} as const;

export type UpdateTaskAnswerRequestAnswerTypeEnum = typeof UpdateTaskAnswerRequestAnswerTypeEnum[keyof typeof UpdateTaskAnswerRequestAnswerTypeEnum];

/**
 * 
 * @export
 * @interface UpdateTaskContentRequest
 */
export interface UpdateTaskContentRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskContentRequest
     */
    'contentType'?: UpdateTaskContentRequestContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskContentRequest
     */
    'contentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskContentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskContentRequest
     */
    'transcription'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskContentRequest
     */
    'translation'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTaskContentRequest
     */
    'orderNum'?: number;
}

export const UpdateTaskContentRequestContentTypeEnum = {
    Audio: 'AUDIO',
    Image: 'IMAGE',
    Text: 'TEXT',
    Video: 'VIDEO'
} as const;

export type UpdateTaskContentRequestContentTypeEnum = typeof UpdateTaskContentRequestContentTypeEnum[keyof typeof UpdateTaskContentRequestContentTypeEnum];

/**
 * 
 * @export
 * @interface UpdateTaskProgressRequest
 */
export interface UpdateTaskProgressRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskProgressRequest
     */
    'status'?: UpdateTaskProgressRequestStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateTaskProgressRequest
     */
    'attemptCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTaskProgressRequest
     */
    'isCorrect'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateTaskProgressRequest
     */
    'shouldRetryAfterTasks'?: number;
}

export const UpdateTaskProgressRequestStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    PendingRetry: 'PENDING_RETRY'
} as const;

export type UpdateTaskProgressRequestStatusEnum = typeof UpdateTaskProgressRequestStatusEnum[keyof typeof UpdateTaskProgressRequestStatusEnum];

/**
 * 
 * @export
 * @interface UpdateTaskRequest
 */
export interface UpdateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'instructions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTaskRequest
     */
    'isTraining'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateTaskRequest
     */
    'orderNum'?: number;
}
/**
 * 
 * @export
 * @interface UpdateThemeRequest
 */
export interface UpdateThemeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateThemeRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateThemeRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateThemeRequest
     */
    'orderNum'?: number;
}
/**
 * 
 * @export
 * @interface UpdateUserProfileRequest
 */
export interface UpdateUserProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'patronymic'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'gender'?: UpdateUserProfileRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'dob'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'dor'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'citizenship'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'countryOfResidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'cityOfResidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'countryDuringEducation'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'periodSpent'?: UpdateUserProfileRequestPeriodSpentEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'kindOfActivity'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'education'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'purposeOfRegister'?: string;
}

export const UpdateUserProfileRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type UpdateUserProfileRequestGenderEnum = typeof UpdateUserProfileRequestGenderEnum[keyof typeof UpdateUserProfileRequestGenderEnum];
export const UpdateUserProfileRequestPeriodSpentEnum = {
    MonthMinus: 'MONTH_MINUS',
    MonthSixMonthsMinus: 'MONTH_SIX_MONTHS_MINUS',
    SixMonths: 'SIX_MONTHS',
    YearMinus: 'YEAR_MINUS',
    YearYearPlus: 'YEAR_YEAR_PLUS',
    YearPlus: 'YEAR_PLUS',
    FiveYearPlus: 'FIVE_YEAR_PLUS',
    FiveYearsPlus: 'FIVE_YEARS_PLUS',
    Never: 'NEVER'
} as const;

export type UpdateUserProfileRequestPeriodSpentEnum = typeof UpdateUserProfileRequestPeriodSpentEnum[keyof typeof UpdateUserProfileRequestPeriodSpentEnum];

/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'role'?: UpdateUserRequestRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'systemLanguage'?: UpdateUserRequestSystemLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'avatarId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'status': UpdateUserRequestStatusEnum;
}

export const UpdateUserRequestRoleEnum = {
    Student: 'STUDENT',
    Expert: 'EXPERT',
    ContentModerator: 'CONTENT_MODERATOR',
    Admin: 'ADMIN'
} as const;

export type UpdateUserRequestRoleEnum = typeof UpdateUserRequestRoleEnum[keyof typeof UpdateUserRequestRoleEnum];
export const UpdateUserRequestSystemLanguageEnum = {
    Russian: 'RUSSIAN',
    Uzbek: 'UZBEK',
    Chinese: 'CHINESE',
    Hindi: 'HINDI',
    Tajik: 'TAJIK',
    English: 'ENGLISH'
} as const;

export type UpdateUserRequestSystemLanguageEnum = typeof UpdateUserRequestSystemLanguageEnum[keyof typeof UpdateUserRequestSystemLanguageEnum];
export const UpdateUserRequestStatusEnum = {
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Deactivated: 'DEACTIVATED',
    PendingVerification: 'PENDING_VERIFICATION'
} as const;

export type UpdateUserRequestStatusEnum = typeof UpdateUserRequestStatusEnum[keyof typeof UpdateUserRequestStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'passwordHash': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'systemLanguage': UserSystemLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatarId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'status': UserStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastActivityAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}

export const UserRoleEnum = {
    Student: 'STUDENT',
    Expert: 'EXPERT',
    ContentModerator: 'CONTENT_MODERATOR',
    Admin: 'ADMIN'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];
export const UserSystemLanguageEnum = {
    Russian: 'RUSSIAN',
    Uzbek: 'UZBEK',
    Chinese: 'CHINESE',
    Hindi: 'HINDI',
    Tajik: 'TAJIK',
    English: 'ENGLISH'
} as const;

export type UserSystemLanguageEnum = typeof UserSystemLanguageEnum[keyof typeof UserSystemLanguageEnum];
export const UserStatusEnum = {
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Deactivated: 'DEACTIVATED',
    PendingVerification: 'PENDING_VERIFICATION'
} as const;

export type UserStatusEnum = typeof UserStatusEnum[keyof typeof UserStatusEnum];

/**
 * 
 * @export
 * @interface UserCourseEnrollmentItem
 */
export interface UserCourseEnrollmentItem {
    /**
     * 
     * @type {string}
     * @memberof UserCourseEnrollmentItem
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseEnrollmentItem
     */
    'courseId': string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseEnrollmentItem
     */
    'enrolledAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseEnrollmentItem
     */
    'completedAt'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserCourseEnrollmentItem
     */
    'progress': object;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'systemLanguage': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface UserInfoData
 */
export interface UserInfoData {
    /**
     * 
     * @type {string}
     * @memberof UserInfoData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoData
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface UserInfoResponse
 */
export interface UserInfoResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoResponse
     */
    'success': boolean;
    /**
     * 
     * @type {UserInfoData}
     * @memberof UserInfoResponse
     */
    'user': UserInfoData;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserInfoResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface UserLanguageSkillRequest
 */
export interface UserLanguageSkillRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLanguageSkillRequest
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserLanguageSkillRequest
     */
    'understands': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserLanguageSkillRequest
     */
    'speaks': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserLanguageSkillRequest
     */
    'reads': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserLanguageSkillRequest
     */
    'writes': boolean;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'patronymic'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'gender': UserProfileGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'dob': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'dor': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'citizenship'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'countryOfResidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'cityOfResidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'countryDuringEducation'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'periodSpent'?: UserProfilePeriodSpentEnum;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'kindOfActivity'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'education'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'purposeOfRegister'?: string;
}

export const UserProfileGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type UserProfileGenderEnum = typeof UserProfileGenderEnum[keyof typeof UserProfileGenderEnum];
export const UserProfilePeriodSpentEnum = {
    MonthMinus: 'MONTH_MINUS',
    MonthSixMonthsMinus: 'MONTH_SIX_MONTHS_MINUS',
    SixMonths: 'SIX_MONTHS',
    YearMinus: 'YEAR_MINUS',
    YearYearPlus: 'YEAR_YEAR_PLUS',
    YearPlus: 'YEAR_PLUS',
    FiveYearPlus: 'FIVE_YEAR_PLUS',
    FiveYearsPlus: 'FIVE_YEARS_PLUS',
    Never: 'NEVER'
} as const;

export type UserProfilePeriodSpentEnum = typeof UserProfilePeriodSpentEnum[keyof typeof UserProfilePeriodSpentEnum];

/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileResponse
     */
    'success': boolean;
    /**
     * 
     * @type {UserProfile}
     * @memberof UserProfileResponse
     */
    'profile': UserProfile;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProfileResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface UserTaskProgressItem
 */
export interface UserTaskProgressItem {
    /**
     * 
     * @type {string}
     * @memberof UserTaskProgressItem
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskProgressItem
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskProgressItem
     */
    'status': UserTaskProgressItemStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof UserTaskProgressItem
     */
    'attemptCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserTaskProgressItem
     */
    'isCorrect'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserTaskProgressItem
     */
    'lastAttemptAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskProgressItem
     */
    'completedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserTaskProgressItem
     */
    'shouldRetryAfterTasks'?: number;
}

export const UserTaskProgressItemStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    PendingRetry: 'PENDING_RETRY'
} as const;

export type UserTaskProgressItemStatusEnum = typeof UserTaskProgressItemStatusEnum[keyof typeof UserTaskProgressItemStatusEnum];

/**
 * 
 * @export
 * @interface UserTaskQueueItem
 */
export interface UserTaskQueueItem {
    /**
     * 
     * @type {string}
     * @memberof UserTaskQueueItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskQueueItem
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskQueueItem
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskQueueItem
     */
    'themeId': string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskQueueItem
     */
    'sectionId': string;
    /**
     * 
     * @type {number}
     * @memberof UserTaskQueueItem
     */
    'queuePosition': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserTaskQueueItem
     */
    'isOriginalTask': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserTaskQueueItem
     */
    'isRetryTask': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserTaskQueueItem
     */
    'originalTaskId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTaskQueueItem
     */
    'createdAt': string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsCourseCourseIdGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('adminStatisticsCourseCourseIdGet', 'courseId', courseId)
            const localVarPath = `/admin/statistics/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsOverallGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/statistics/overall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsStudentsCourseCourseIdGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('adminStatisticsStudentsCourseCourseIdGet', 'courseId', courseId)
            const localVarPath = `/admin/statistics/students/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsStudentsOverallGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/statistics/students/overall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [role] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersCountGet: async (role?: string, createdFrom?: string, createdTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (createdFrom !== undefined) {
                localVarQueryParameter['createdFrom'] = createdFrom;
            }

            if (createdTo !== undefined) {
                localVarQueryParameter['createdTo'] = createdTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [role] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersGet: async (page?: number, size?: number, role?: string, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (createdFrom !== undefined) {
                localVarQueryParameter['createdFrom'] = createdFrom;
            }

            if (createdTo !== undefined) {
                localVarQueryParameter['createdTo'] = createdTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StaffRegisterRequest} staffRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersStaffPost: async (staffRegisterRequest: StaffRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffRegisterRequest' is not null or undefined
            assertParamExists('adminUsersStaffPost', 'staffRegisterRequest', staffRegisterRequest)
            const localVarPath = `/admin/users/staff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdGet', 'userId', userId)
            const localVarPath = `/admin/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileStaffDelete', 'userId', userId)
            const localVarPath = `/admin/users/{userId}/profile/staff`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileStaffGet', 'userId', userId)
            const localVarPath = `/admin/users/{userId}/profile/staff`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {CreateStaffProfileRequest} createStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffPost: async (userId: string, createStaffProfileRequest: CreateStaffProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileStaffPost', 'userId', userId)
            // verify required parameter 'createStaffProfileRequest' is not null or undefined
            assertParamExists('adminUsersUserIdProfileStaffPost', 'createStaffProfileRequest', createStaffProfileRequest)
            const localVarPath = `/admin/users/{userId}/profile/staff`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStaffProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffPut: async (userId: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileStaffPut', 'userId', userId)
            // verify required parameter 'updateStaffProfileRequest' is not null or undefined
            assertParamExists('adminUsersUserIdProfileStaffPut', 'updateStaffProfileRequest', updateStaffProfileRequest)
            const localVarPath = `/admin/users/{userId}/profile/staff`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStaffProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileUserDelete', 'userId', userId)
            const localVarPath = `/admin/users/{userId}/profile/user`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileUserGet', 'userId', userId)
            const localVarPath = `/admin/users/{userId}/profile/user`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserPost: async (userId: string, createUserProfileRequest: CreateUserProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileUserPost', 'userId', userId)
            // verify required parameter 'createUserProfileRequest' is not null or undefined
            assertParamExists('adminUsersUserIdProfileUserPost', 'createUserProfileRequest', createUserProfileRequest)
            const localVarPath = `/admin/users/{userId}/profile/user`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserPut: async (userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdProfileUserPut', 'userId', userId)
            // verify required parameter 'updateUserProfileRequest' is not null or undefined
            assertParamExists('adminUsersUserIdProfileUserPut', 'updateUserProfileRequest', updateUserProfileRequest)
            const localVarPath = `/admin/users/{userId}/profile/user`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdPut: async (userId: string, updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdPut', 'userId', userId)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('adminUsersUserIdPut', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/admin/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdStatusPut: async (userId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUsersUserIdStatusPut', 'userId', userId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('adminUsersUserIdStatusPut', 'body', body)
            const localVarPath = `/admin/users/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminStatisticsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminStatisticsCourseCourseIdGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminStatisticsCourseCourseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminStatisticsOverallGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminStatisticsOverallGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminStatisticsOverallGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminStatisticsStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminStatisticsStudentsCourseCourseIdGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminStatisticsStudentsCourseCourseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminStatisticsStudentsOverallGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminStatisticsStudentsOverallGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminStatisticsStudentsOverallGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [role] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersCountGet(role?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersCountGet(role, createdFrom, createdTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [role] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersGet(page?: number, size?: number, role?: string, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersGet(page, size, role, sortBy, sortOrder, createdFrom, createdTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StaffRegisterRequest} staffRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersStaffPost(staffRegisterRequest: StaffRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersStaffPost(staffRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersStaffPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileStaffDelete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileStaffDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileStaffDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileStaffGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileStaffGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileStaffGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {CreateStaffProfileRequest} createStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileStaffPost(userId: string, createStaffProfileRequest: CreateStaffProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileStaffPost(userId, createStaffProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileStaffPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileStaffPut(userId: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileStaffPut(userId, updateStaffProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileStaffPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileUserDelete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileUserDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileUserDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileUserGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileUserGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileUserPost(userId: string, createUserProfileRequest: CreateUserProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileUserPost(userId, createUserProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdProfileUserPut(userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdProfileUserPut(userId, updateUserProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdProfileUserPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdPut(userId: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdPut(userId, updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUserIdStatusPut(userId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUserIdStatusPut(userId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersUserIdStatusPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.adminStatisticsCourseCourseIdGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsOverallGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.adminStatisticsOverallGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.adminStatisticsStudentsCourseCourseIdGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminStatisticsStudentsOverallGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.adminStatisticsStudentsOverallGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [role] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersCountGet(role?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.adminUsersCountGet(role, createdFrom, createdTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [role] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersGet(page?: number, size?: number, role?: string, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.adminUsersGet(page, size, role, sortBy, sortOrder, createdFrom, createdTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StaffRegisterRequest} staffRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersStaffPost(staffRegisterRequest: StaffRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.adminUsersStaffPost(staffRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.adminUsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffDelete(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.adminUsersUserIdProfileStaffDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.adminUsersUserIdProfileStaffGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {CreateStaffProfileRequest} createStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffPost(userId: string, createStaffProfileRequest: CreateStaffProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.adminUsersUserIdProfileStaffPost(userId, createStaffProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileStaffPut(userId: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.adminUsersUserIdProfileStaffPut(userId, updateStaffProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserDelete(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.adminUsersUserIdProfileUserDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.adminUsersUserIdProfileUserGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserPost(userId: string, createUserProfileRequest: CreateUserProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.adminUsersUserIdProfileUserPost(userId, createUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdProfileUserPut(userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.adminUsersUserIdProfileUserPut(userId, updateUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdPut(userId: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.adminUsersUserIdPut(userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUserIdStatusPut(userId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.adminUsersUserIdStatusPut(userId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminStatisticsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminStatisticsCourseCourseIdGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminStatisticsOverallGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminStatisticsOverallGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminStatisticsStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminStatisticsStudentsCourseCourseIdGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminStatisticsStudentsOverallGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminStatisticsStudentsOverallGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [role] 
     * @param {string} [createdFrom] 
     * @param {string} [createdTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersCountGet(role?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersCountGet(role, createdFrom, createdTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [role] 
     * @param {string} [sortBy] 
     * @param {string} [sortOrder] 
     * @param {string} [createdFrom] 
     * @param {string} [createdTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersGet(page?: number, size?: number, role?: string, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersGet(page, size, role, sortBy, sortOrder, createdFrom, createdTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StaffRegisterRequest} staffRegisterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersStaffPost(staffRegisterRequest: StaffRegisterRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersStaffPost(staffRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileStaffDelete(userId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileStaffDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileStaffGet(userId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileStaffGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {CreateStaffProfileRequest} createStaffProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileStaffPost(userId: string, createStaffProfileRequest: CreateStaffProfileRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileStaffPost(userId, createStaffProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileStaffPut(userId: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileStaffPut(userId, updateStaffProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileUserDelete(userId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileUserDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileUserGet(userId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileUserGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {CreateUserProfileRequest} createUserProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileUserPost(userId: string, createUserProfileRequest: CreateUserProfileRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileUserPost(userId, createUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {UpdateUserProfileRequest} updateUserProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdProfileUserPut(userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdProfileUserPut(userId, updateUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdPut(userId: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdPut(userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersUserIdStatusPut(userId: string, body: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersUserIdStatusPut(userId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAdminCreateInitialPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/admin/create-initial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshPost: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('authRefreshPost', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StaffRegisterRequest} staffRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authStaffRegisterPost: async (staffRegisterRequest: StaffRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffRegisterRequest' is not null or undefined
            assertParamExists('authStaffRegisterPost', 'staffRegisterRequest', staffRegisterRequest)
            const localVarPath = `/auth/staff/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StudentRegisterRequest} studentRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authStudentRegisterPost: async (studentRegisterRequest: StudentRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentRegisterRequest' is not null or undefined
            assertParamExists('authStudentRegisterPost', 'studentRegisterRequest', studentRegisterRequest)
            const localVarPath = `/auth/student/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAdminCreateInitialPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCreatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAdminCreateInitialPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authAdminCreateInitialPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshPost(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StaffRegisterRequest} staffRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authStaffRegisterPost(staffRegisterRequest: StaffRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authStaffRegisterPost(staffRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authStaffRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StudentRegisterRequest} studentRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authStudentRegisterPost(studentRegisterRequest: StudentRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authStudentRegisterPost(studentRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authStudentRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAdminCreateInitialPost(options?: RawAxiosRequestConfig): AxiosPromise<AdminCreatedResponse> {
            return localVarFp.authAdminCreateInitialPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.authLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeGet(options?: RawAxiosRequestConfig): AxiosPromise<UserInfoResponse> {
            return localVarFp.authMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authRefreshPost(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StaffRegisterRequest} staffRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authStaffRegisterPost(staffRegisterRequest: StaffRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authStaffRegisterPost(staffRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StudentRegisterRequest} studentRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authStudentRegisterPost(studentRegisterRequest: StudentRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authStudentRegisterPost(studentRegisterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAdminCreateInitialPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAdminCreateInitialPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMeGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshPost(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StaffRegisterRequest} staffRegisterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authStaffRegisterPost(staffRegisterRequest: StaffRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authStaffRegisterPost(staffRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StudentRegisterRequest} studentRegisterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authStudentRegisterPost(studentRegisterRequest: StudentRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authStudentRegisterPost(studentRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesCourseIdDelete: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('contentCoursesCourseIdDelete', 'courseId', courseId)
            const localVarPath = `/content/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesCourseIdGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('contentCoursesCourseIdGet', 'courseId', courseId)
            const localVarPath = `/content/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {UpdateCourseRequest} updateCourseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesCourseIdPut: async (courseId: string, updateCourseRequest: UpdateCourseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('contentCoursesCourseIdPut', 'courseId', courseId)
            // verify required parameter 'updateCourseRequest' is not null or undefined
            assertParamExists('contentCoursesCourseIdPut', 'updateCourseRequest', updateCourseRequest)
            const localVarPath = `/content/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCourseRequest} createCourseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesPost: async (createCourseRequest: CreateCourseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCourseRequest' is not null or undefined
            assertParamExists('contentCoursesPost', 'createCourseRequest', createCourseRequest)
            const localVarPath = `/content/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsPost: async (createReportRequest: CreateReportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createReportRequest' is not null or undefined
            assertParamExists('contentReportsPost', 'createReportRequest', createReportRequest)
            const localVarPath = `/content/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsReportIdDelete: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('contentReportsReportIdDelete', 'reportId', reportId)
            const localVarPath = `/content/reports/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsReportIdGet: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('contentReportsReportIdGet', 'reportId', reportId)
            const localVarPath = `/content/reports/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsByCourseCourseIdGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('contentSectionsByCourseCourseIdGet', 'courseId', courseId)
            const localVarPath = `/content/sections/by-course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateSectionRequest} createSectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsPost: async (createSectionRequest: CreateSectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSectionRequest' is not null or undefined
            assertParamExists('contentSectionsPost', 'createSectionRequest', createSectionRequest)
            const localVarPath = `/content/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsSectionIdDelete: async (sectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('contentSectionsSectionIdDelete', 'sectionId', sectionId)
            const localVarPath = `/content/sections/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsSectionIdGet: async (sectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('contentSectionsSectionIdGet', 'sectionId', sectionId)
            const localVarPath = `/content/sections/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {UpdateSectionRequest} updateSectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsSectionIdPut: async (sectionId: string, updateSectionRequest: UpdateSectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('contentSectionsSectionIdPut', 'sectionId', sectionId)
            // verify required parameter 'updateSectionRequest' is not null or undefined
            assertParamExists('contentSectionsSectionIdPut', 'updateSectionRequest', updateSectionRequest)
            const localVarPath = `/content/sections/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsCourseCourseIdTasksCountGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('contentStatsCourseCourseIdTasksCountGet', 'courseId', courseId)
            const localVarPath = `/content/stats/course/{courseId}/tasks-count`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsSectionSectionIdTasksCountGet: async (sectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('contentStatsSectionSectionIdTasksCountGet', 'sectionId', sectionId)
            const localVarPath = `/content/stats/section/{sectionId}/tasks-count`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsThemeThemeIdTasksCountGet: async (themeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('contentStatsThemeThemeIdTasksCountGet', 'themeId', themeId)
            const localVarPath = `/content/stats/theme/{themeId}/tasks-count`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksPost: async (createTaskRequest: CreateTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskRequest' is not null or undefined
            assertParamExists('contentTasksPost', 'createTaskRequest', createTaskRequest)
            const localVarPath = `/content/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerDelete: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdAnswerDelete', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}/answer`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdAnswerGet', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}/answer`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskAnswerRequest} createTaskAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerPost: async (taskId: string, createTaskAnswerRequest: CreateTaskAnswerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdAnswerPost', 'taskId', taskId)
            // verify required parameter 'createTaskAnswerRequest' is not null or undefined
            assertParamExists('contentTasksTaskIdAnswerPost', 'createTaskAnswerRequest', createTaskAnswerRequest)
            const localVarPath = `/content/tasks/{taskId}/answer`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskAnswerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskAnswerRequest} updateTaskAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerPut: async (taskId: string, updateTaskAnswerRequest: UpdateTaskAnswerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdAnswerPut', 'taskId', taskId)
            // verify required parameter 'updateTaskAnswerRequest' is not null or undefined
            assertParamExists('contentTasksTaskIdAnswerPut', 'updateTaskAnswerRequest', updateTaskAnswerRequest)
            const localVarPath = `/content/tasks/{taskId}/answer`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskAnswerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentContentIdDelete: async (contentId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('contentTasksTaskIdContentContentIdDelete', 'contentId', contentId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdContentContentIdDelete', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}/content/{contentId}`
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentContentIdGet: async (contentId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('contentTasksTaskIdContentContentIdGet', 'contentId', contentId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdContentContentIdGet', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}/content/{contentId}`
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {UpdateTaskContentRequest} updateTaskContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentContentIdPut: async (contentId: string, taskId: string, updateTaskContentRequest: UpdateTaskContentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('contentTasksTaskIdContentContentIdPut', 'contentId', contentId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdContentContentIdPut', 'taskId', taskId)
            // verify required parameter 'updateTaskContentRequest' is not null or undefined
            assertParamExists('contentTasksTaskIdContentContentIdPut', 'updateTaskContentRequest', updateTaskContentRequest)
            const localVarPath = `/content/tasks/{taskId}/content/{contentId}`
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskContentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskContentRequest} createTaskContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentPost: async (taskId: string, createTaskContentRequest: CreateTaskContentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdContentPost', 'taskId', taskId)
            // verify required parameter 'createTaskContentRequest' is not null or undefined
            assertParamExists('contentTasksTaskIdContentPost', 'createTaskContentRequest', createTaskContentRequest)
            const localVarPath = `/content/tasks/{taskId}/content`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskContentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdDelete: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdDelete', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdGet', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsOptionIdDelete: async (optionId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsOptionIdDelete', 'optionId', optionId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsOptionIdDelete', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}/options/{optionId}`
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsOptionIdGet: async (optionId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsOptionIdGet', 'optionId', optionId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsOptionIdGet', 'taskId', taskId)
            const localVarPath = `/content/tasks/{taskId}/options/{optionId}`
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {UpdateTaskAnswerOptionRequest} updateTaskAnswerOptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsOptionIdPut: async (optionId: string, taskId: string, updateTaskAnswerOptionRequest: UpdateTaskAnswerOptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsOptionIdPut', 'optionId', optionId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsOptionIdPut', 'taskId', taskId)
            // verify required parameter 'updateTaskAnswerOptionRequest' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsOptionIdPut', 'updateTaskAnswerOptionRequest', updateTaskAnswerOptionRequest)
            const localVarPath = `/content/tasks/{taskId}/options/{optionId}`
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskAnswerOptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskAnswerOptionRequest} createTaskAnswerOptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsPost: async (taskId: string, createTaskAnswerOptionRequest: CreateTaskAnswerOptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsPost', 'taskId', taskId)
            // verify required parameter 'createTaskAnswerOptionRequest' is not null or undefined
            assertParamExists('contentTasksTaskIdOptionsPost', 'createTaskAnswerOptionRequest', createTaskAnswerOptionRequest)
            const localVarPath = `/content/tasks/{taskId}/options`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskAnswerOptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdPut: async (taskId: string, updateTaskRequest: UpdateTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('contentTasksTaskIdPut', 'taskId', taskId)
            // verify required parameter 'updateTaskRequest' is not null or undefined
            assertParamExists('contentTasksTaskIdPut', 'updateTaskRequest', updateTaskRequest)
            const localVarPath = `/content/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesBySectionSectionIdGet: async (sectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('contentThemesBySectionSectionIdGet', 'sectionId', sectionId)
            const localVarPath = `/content/themes/by-section/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateThemeRequest} createThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesPost: async (createThemeRequest: CreateThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createThemeRequest' is not null or undefined
            assertParamExists('contentThemesPost', 'createThemeRequest', createThemeRequest)
            const localVarPath = `/content/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdDelete: async (themeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('contentThemesThemeIdDelete', 'themeId', themeId)
            const localVarPath = `/content/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdGet: async (themeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('contentThemesThemeIdGet', 'themeId', themeId)
            const localVarPath = `/content/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} themeId 
         * @param {UpdateThemeRequest} updateThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdPut: async (themeId: string, updateThemeRequest: UpdateThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('contentThemesThemeIdPut', 'themeId', themeId)
            // verify required parameter 'updateThemeRequest' is not null or undefined
            assertParamExists('contentThemesThemeIdPut', 'updateThemeRequest', updateThemeRequest)
            const localVarPath = `/content/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdTasksGet: async (themeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('contentThemesThemeIdTasksGet', 'themeId', themeId)
            const localVarPath = `/content/themes/{themeId}/tasks`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentCoursesCourseIdDelete(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentCoursesCourseIdDelete(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentCoursesCourseIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentCoursesCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentCoursesCourseIdGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentCoursesCourseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {UpdateCourseRequest} updateCourseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentCoursesCourseIdPut(courseId: string, updateCourseRequest: UpdateCourseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentCoursesCourseIdPut(courseId, updateCourseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentCoursesCourseIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentCoursesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentCoursesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentCoursesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCourseRequest} createCourseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentCoursesPost(createCourseRequest: CreateCourseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentCoursesPost(createCourseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentCoursesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentReportsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Report>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentReportsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentReportsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentReportsPost(createReportRequest: CreateReportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentReportsPost(createReportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentReportsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentReportsReportIdDelete(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentReportsReportIdDelete(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentReportsReportIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentReportsReportIdGet(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentReportsReportIdGet(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentReportsReportIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentSectionsByCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Section>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentSectionsByCourseCourseIdGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentSectionsByCourseCourseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateSectionRequest} createSectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentSectionsPost(createSectionRequest: CreateSectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentSectionsPost(createSectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentSectionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentSectionsSectionIdDelete(sectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentSectionsSectionIdDelete(sectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentSectionsSectionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentSectionsSectionIdGet(sectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentSectionsSectionIdGet(sectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentSectionsSectionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {UpdateSectionRequest} updateSectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentSectionsSectionIdPut(sectionId: string, updateSectionRequest: UpdateSectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentSectionsSectionIdPut(sectionId, updateSectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentSectionsSectionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentStatsCourseCourseIdTasksCountGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentStatsCourseCourseIdTasksCountGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentStatsCourseCourseIdTasksCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentStatsSectionSectionIdTasksCountGet(sectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentStatsSectionSectionIdTasksCountGet(sectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentStatsSectionSectionIdTasksCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentStatsThemeThemeIdTasksCountGet(themeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentStatsThemeThemeIdTasksCountGet(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentStatsThemeThemeIdTasksCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksPost(createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksPost(createTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdAnswerDelete(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdAnswerDelete(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdAnswerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdAnswerGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskAnswerItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdAnswerGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdAnswerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskAnswerRequest} createTaskAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdAnswerPost(taskId: string, createTaskAnswerRequest: CreateTaskAnswerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskAnswerItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdAnswerPost(taskId, createTaskAnswerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdAnswerPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskAnswerRequest} updateTaskAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdAnswerPut(taskId: string, updateTaskAnswerRequest: UpdateTaskAnswerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskAnswerItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdAnswerPut(taskId, updateTaskAnswerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdAnswerPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdContentContentIdDelete(contentId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdContentContentIdDelete(contentId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdContentContentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdContentContentIdGet(contentId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskContentItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdContentContentIdGet(contentId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdContentContentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {UpdateTaskContentRequest} updateTaskContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdContentContentIdPut(contentId: string, taskId: string, updateTaskContentRequest: UpdateTaskContentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskContentItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdContentContentIdPut(contentId, taskId, updateTaskContentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdContentContentIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskContentRequest} createTaskContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdContentPost(taskId: string, createTaskContentRequest: CreateTaskContentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskContentItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdContentPost(taskId, createTaskContentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdContentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdDelete(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdDelete(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdOptionsOptionIdDelete(optionId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdOptionsOptionIdDelete(optionId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdOptionsOptionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdOptionsOptionIdGet(optionId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskAnswerOptionItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdOptionsOptionIdGet(optionId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdOptionsOptionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {UpdateTaskAnswerOptionRequest} updateTaskAnswerOptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdOptionsOptionIdPut(optionId: string, taskId: string, updateTaskAnswerOptionRequest: UpdateTaskAnswerOptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskAnswerOptionItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdOptionsOptionIdPut(optionId, taskId, updateTaskAnswerOptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdOptionsOptionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskAnswerOptionRequest} createTaskAnswerOptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdOptionsPost(taskId: string, createTaskAnswerOptionRequest: CreateTaskAnswerOptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskAnswerOptionItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdOptionsPost(taskId, createTaskAnswerOptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdOptionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTasksTaskIdPut(taskId: string, updateTaskRequest: UpdateTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTasksTaskIdPut(taskId, updateTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTasksTaskIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentThemesBySectionSectionIdGet(sectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Theme>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentThemesBySectionSectionIdGet(sectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentThemesBySectionSectionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateThemeRequest} createThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentThemesPost(createThemeRequest: CreateThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentThemesPost(createThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentThemesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentThemesThemeIdDelete(themeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentThemesThemeIdDelete(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentThemesThemeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentThemesThemeIdGet(themeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentThemesThemeIdGet(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentThemesThemeIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} themeId 
         * @param {UpdateThemeRequest} updateThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentThemesThemeIdPut(themeId: string, updateThemeRequest: UpdateThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentThemesThemeIdPut(themeId, updateThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentThemesThemeIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentThemesThemeIdTasksGet(themeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskWithDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentThemesThemeIdTasksGet(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentThemesThemeIdTasksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesCourseIdDelete(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentCoursesCourseIdDelete(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.contentCoursesCourseIdGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {UpdateCourseRequest} updateCourseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesCourseIdPut(courseId: string, updateCourseRequest: UpdateCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.contentCoursesCourseIdPut(courseId, updateCourseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Course>> {
            return localVarFp.contentCoursesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCourseRequest} createCourseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCoursesPost(createCourseRequest: CreateCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.contentCoursesPost(createCourseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Report>> {
            return localVarFp.contentReportsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsPost(createReportRequest: CreateReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.contentReportsPost(createReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsReportIdDelete(reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentReportsReportIdDelete(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReportsReportIdGet(reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.contentReportsReportIdGet(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsByCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Section>> {
            return localVarFp.contentSectionsByCourseCourseIdGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateSectionRequest} createSectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsPost(createSectionRequest: CreateSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Section> {
            return localVarFp.contentSectionsPost(createSectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsSectionIdDelete(sectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentSectionsSectionIdDelete(sectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsSectionIdGet(sectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Section> {
            return localVarFp.contentSectionsSectionIdGet(sectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {UpdateSectionRequest} updateSectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentSectionsSectionIdPut(sectionId: string, updateSectionRequest: UpdateSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Section> {
            return localVarFp.contentSectionsSectionIdPut(sectionId, updateSectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsCourseCourseIdTasksCountGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentStatsCourseCourseIdTasksCountGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<CountStats> {
            return localVarFp.contentStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsSectionSectionIdTasksCountGet(sectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentStatsSectionSectionIdTasksCountGet(sectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsThemeThemeIdTasksCountGet(themeId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentStatsThemeThemeIdTasksCountGet(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksPost(createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskWithDetails> {
            return localVarFp.contentTasksPost(createTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerDelete(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentTasksTaskIdAnswerDelete(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskAnswerItem> {
            return localVarFp.contentTasksTaskIdAnswerGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskAnswerRequest} createTaskAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerPost(taskId: string, createTaskAnswerRequest: CreateTaskAnswerRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskAnswerItem> {
            return localVarFp.contentTasksTaskIdAnswerPost(taskId, createTaskAnswerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskAnswerRequest} updateTaskAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdAnswerPut(taskId: string, updateTaskAnswerRequest: UpdateTaskAnswerRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskAnswerItem> {
            return localVarFp.contentTasksTaskIdAnswerPut(taskId, updateTaskAnswerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentContentIdDelete(contentId: string, taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentTasksTaskIdContentContentIdDelete(contentId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentContentIdGet(contentId: string, taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskContentItem> {
            return localVarFp.contentTasksTaskIdContentContentIdGet(contentId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contentId 
         * @param {string} taskId 
         * @param {UpdateTaskContentRequest} updateTaskContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentContentIdPut(contentId: string, taskId: string, updateTaskContentRequest: UpdateTaskContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskContentItem> {
            return localVarFp.contentTasksTaskIdContentContentIdPut(contentId, taskId, updateTaskContentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskContentRequest} createTaskContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdContentPost(taskId: string, createTaskContentRequest: CreateTaskContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskContentItem> {
            return localVarFp.contentTasksTaskIdContentPost(taskId, createTaskContentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdDelete(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentTasksTaskIdDelete(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskWithDetails> {
            return localVarFp.contentTasksTaskIdGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsOptionIdDelete(optionId: string, taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentTasksTaskIdOptionsOptionIdDelete(optionId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsOptionIdGet(optionId: string, taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskAnswerOptionItem> {
            return localVarFp.contentTasksTaskIdOptionsOptionIdGet(optionId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} optionId 
         * @param {string} taskId 
         * @param {UpdateTaskAnswerOptionRequest} updateTaskAnswerOptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsOptionIdPut(optionId: string, taskId: string, updateTaskAnswerOptionRequest: UpdateTaskAnswerOptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskAnswerOptionItem> {
            return localVarFp.contentTasksTaskIdOptionsOptionIdPut(optionId, taskId, updateTaskAnswerOptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {CreateTaskAnswerOptionRequest} createTaskAnswerOptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdOptionsPost(taskId: string, createTaskAnswerOptionRequest: CreateTaskAnswerOptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskAnswerOptionItem> {
            return localVarFp.contentTasksTaskIdOptionsPost(taskId, createTaskAnswerOptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTasksTaskIdPut(taskId: string, updateTaskRequest: UpdateTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskWithDetails> {
            return localVarFp.contentTasksTaskIdPut(taskId, updateTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesBySectionSectionIdGet(sectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Theme>> {
            return localVarFp.contentThemesBySectionSectionIdGet(sectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateThemeRequest} createThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesPost(createThemeRequest: CreateThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.contentThemesPost(createThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdDelete(themeId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.contentThemesThemeIdDelete(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdGet(themeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.contentThemesThemeIdGet(themeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} themeId 
         * @param {UpdateThemeRequest} updateThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdPut(themeId: string, updateThemeRequest: UpdateThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Theme> {
            return localVarFp.contentThemesThemeIdPut(themeId, updateThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentThemesThemeIdTasksGet(themeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskWithDetails>> {
            return localVarFp.contentThemesThemeIdTasksGet(themeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentCoursesCourseIdDelete(courseId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentCoursesCourseIdDelete(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentCoursesCourseIdGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentCoursesCourseIdGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {UpdateCourseRequest} updateCourseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentCoursesCourseIdPut(courseId: string, updateCourseRequest: UpdateCourseRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentCoursesCourseIdPut(courseId, updateCourseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentCoursesGet(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentCoursesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCourseRequest} createCourseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentCoursesPost(createCourseRequest: CreateCourseRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentCoursesPost(createCourseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentReportsGet(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentReportsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateReportRequest} createReportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentReportsPost(createReportRequest: CreateReportRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentReportsPost(createReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentReportsReportIdDelete(reportId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentReportsReportIdDelete(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentReportsReportIdGet(reportId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentReportsReportIdGet(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentSectionsByCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentSectionsByCourseCourseIdGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateSectionRequest} createSectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentSectionsPost(createSectionRequest: CreateSectionRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentSectionsPost(createSectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentSectionsSectionIdDelete(sectionId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentSectionsSectionIdDelete(sectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentSectionsSectionIdGet(sectionId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentSectionsSectionIdGet(sectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sectionId 
     * @param {UpdateSectionRequest} updateSectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentSectionsSectionIdPut(sectionId: string, updateSectionRequest: UpdateSectionRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentSectionsSectionIdPut(sectionId, updateSectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentStatsCourseCourseIdTasksCountGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentStatsCourseCourseIdTasksCountGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentStatsGet(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentStatsSectionSectionIdTasksCountGet(sectionId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentStatsSectionSectionIdTasksCountGet(sectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentStatsThemeThemeIdTasksCountGet(themeId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentStatsThemeThemeIdTasksCountGet(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTaskRequest} createTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksPost(createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksPost(createTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdAnswerDelete(taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdAnswerDelete(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdAnswerGet(taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdAnswerGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {CreateTaskAnswerRequest} createTaskAnswerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdAnswerPost(taskId: string, createTaskAnswerRequest: CreateTaskAnswerRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdAnswerPost(taskId, createTaskAnswerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {UpdateTaskAnswerRequest} updateTaskAnswerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdAnswerPut(taskId: string, updateTaskAnswerRequest: UpdateTaskAnswerRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdAnswerPut(taskId, updateTaskAnswerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contentId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdContentContentIdDelete(contentId: string, taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdContentContentIdDelete(contentId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contentId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdContentContentIdGet(contentId: string, taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdContentContentIdGet(contentId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contentId 
     * @param {string} taskId 
     * @param {UpdateTaskContentRequest} updateTaskContentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdContentContentIdPut(contentId: string, taskId: string, updateTaskContentRequest: UpdateTaskContentRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdContentContentIdPut(contentId, taskId, updateTaskContentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {CreateTaskContentRequest} createTaskContentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdContentPost(taskId: string, createTaskContentRequest: CreateTaskContentRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdContentPost(taskId, createTaskContentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdDelete(taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdDelete(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdGet(taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} optionId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdOptionsOptionIdDelete(optionId: string, taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdOptionsOptionIdDelete(optionId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} optionId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdOptionsOptionIdGet(optionId: string, taskId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdOptionsOptionIdGet(optionId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} optionId 
     * @param {string} taskId 
     * @param {UpdateTaskAnswerOptionRequest} updateTaskAnswerOptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdOptionsOptionIdPut(optionId: string, taskId: string, updateTaskAnswerOptionRequest: UpdateTaskAnswerOptionRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdOptionsOptionIdPut(optionId, taskId, updateTaskAnswerOptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {CreateTaskAnswerOptionRequest} createTaskAnswerOptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdOptionsPost(taskId: string, createTaskAnswerOptionRequest: CreateTaskAnswerOptionRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdOptionsPost(taskId, createTaskAnswerOptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {UpdateTaskRequest} updateTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentTasksTaskIdPut(taskId: string, updateTaskRequest: UpdateTaskRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTasksTaskIdPut(taskId, updateTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentThemesBySectionSectionIdGet(sectionId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentThemesBySectionSectionIdGet(sectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateThemeRequest} createThemeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentThemesPost(createThemeRequest: CreateThemeRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentThemesPost(createThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentThemesThemeIdDelete(themeId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentThemesThemeIdDelete(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentThemesThemeIdGet(themeId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentThemesThemeIdGet(themeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} themeId 
     * @param {UpdateThemeRequest} updateThemeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentThemesThemeIdPut(themeId: string, updateThemeRequest: UpdateThemeRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentThemesThemeIdPut(themeId, updateThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentThemesThemeIdTasksGet(themeId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentThemesThemeIdTasksGet(themeId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExpertApi - axios parameter creator
 * @export
 */
export const ExpertApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentCoursesCourseIdGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('expertContentCoursesCourseIdGet', 'courseId', courseId)
            const localVarPath = `/expert/content/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentCoursesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/content/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentReportsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/content/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/content/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsCourseCourseIdAverageProgressGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('expertStatisticsCourseCourseIdAverageProgressGet', 'courseId', courseId)
            const localVarPath = `/expert/statistics/course/{courseId}/average-progress`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsCourseCourseIdAverageTimeGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('expertStatisticsCourseCourseIdAverageTimeGet', 'courseId', courseId)
            const localVarPath = `/expert/statistics/course/{courseId}/average-time`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsOverallAverageProgressGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/statistics/overall-average-progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsOverallAverageTimeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/statistics/overall-average-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsStudentsCourseCourseIdGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('expertStatisticsStudentsCourseCourseIdGet', 'courseId', courseId)
            const localVarPath = `/expert/statistics/students/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsStudentsOverallGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/statistics/students/overall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsCountGet: async (createdFrom?: string, createdTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/students/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdFrom !== undefined) {
                localVarQueryParameter['createdFrom'] = createdFrom;
            }

            if (createdTo !== undefined) {
                localVarQueryParameter['createdTo'] = createdTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsCourseCourseIdGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('expertStudentsCourseCourseIdGet', 'courseId', courseId)
            const localVarPath = `/expert/students/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsGet: async (page?: number, size?: number, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/students`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (createdFrom !== undefined) {
                localVarQueryParameter['createdFrom'] = createdFrom;
            }

            if (createdTo !== undefined) {
                localVarQueryParameter['createdTo'] = createdTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsWithProfilesGet: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expert/students/with-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExpertApi - functional programming interface
 * @export
 */
export const ExpertApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExpertApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertContentCoursesCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertContentCoursesCourseIdGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertContentCoursesCourseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertContentCoursesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertContentCoursesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertContentCoursesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertContentReportsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Report>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertContentReportsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertContentReportsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertContentStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertContentStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertContentStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStatisticsCourseCourseIdAverageProgressGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStatisticsCourseCourseIdAverageProgressGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStatisticsCourseCourseIdAverageProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStatisticsCourseCourseIdAverageTimeGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStatisticsCourseCourseIdAverageTimeGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStatisticsCourseCourseIdAverageTimeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStatisticsOverallAverageProgressGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStatisticsOverallAverageProgressGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStatisticsOverallAverageProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStatisticsOverallAverageTimeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStatisticsOverallAverageTimeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStatisticsOverallAverageTimeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStatisticsStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStatisticsStudentsCourseCourseIdGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStatisticsStudentsCourseCourseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStatisticsStudentsOverallGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStatisticsStudentsOverallGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStatisticsStudentsOverallGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStudentsCountGet(createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStudentsCountGet(createdFrom, createdTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStudentsCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStudentsCourseCourseIdGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStudentsCourseCourseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStudentsGet(page?: number, size?: number, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStudentsGet(page, size, sortBy, sortOrder, createdFrom, createdTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStudentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expertStudentsWithProfilesGet(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expertStudentsWithProfilesGet(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExpertApi.expertStudentsWithProfilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExpertApi - factory interface
 * @export
 */
export const ExpertApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExpertApiFp(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentCoursesCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.expertContentCoursesCourseIdGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentCoursesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Course>> {
            return localVarFp.expertContentCoursesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentReportsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Report>> {
            return localVarFp.expertContentReportsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertContentStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<CountStats> {
            return localVarFp.expertContentStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsCourseCourseIdAverageProgressGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.expertStatisticsCourseCourseIdAverageProgressGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsCourseCourseIdAverageTimeGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.expertStatisticsCourseCourseIdAverageTimeGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsOverallAverageProgressGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.expertStatisticsOverallAverageProgressGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsOverallAverageTimeGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.expertStatisticsOverallAverageTimeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.expertStatisticsStudentsCourseCourseIdGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStatisticsStudentsOverallGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.expertStatisticsStudentsOverallGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsCountGet(createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.expertStudentsCountGet(createdFrom, createdTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.expertStudentsCourseCourseIdGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [createdFrom] 
         * @param {string} [createdTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsGet(page?: number, size?: number, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.expertStudentsGet(page, size, sortBy, sortOrder, createdFrom, createdTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expertStudentsWithProfilesGet(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.expertStudentsWithProfilesGet(page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExpertApi - object-oriented interface
 * @export
 * @class ExpertApi
 * @extends {BaseAPI}
 */
export class ExpertApi extends BaseAPI {
    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertContentCoursesCourseIdGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertContentCoursesCourseIdGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertContentCoursesGet(options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertContentCoursesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertContentReportsGet(options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertContentReportsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertContentStatsGet(options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertContentStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStatisticsCourseCourseIdAverageProgressGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStatisticsCourseCourseIdAverageProgressGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStatisticsCourseCourseIdAverageTimeGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStatisticsCourseCourseIdAverageTimeGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStatisticsOverallAverageProgressGet(options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStatisticsOverallAverageProgressGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStatisticsOverallAverageTimeGet(options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStatisticsOverallAverageTimeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStatisticsStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStatisticsStudentsCourseCourseIdGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStatisticsStudentsOverallGet(options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStatisticsStudentsOverallGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdFrom] 
     * @param {string} [createdTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStudentsCountGet(createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStudentsCountGet(createdFrom, createdTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStudentsCourseCourseIdGet(courseId: string, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStudentsCourseCourseIdGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [sortOrder] 
     * @param {string} [createdFrom] 
     * @param {string} [createdTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStudentsGet(page?: number, size?: number, sortBy?: string, sortOrder?: string, createdFrom?: string, createdTo?: string, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStudentsGet(page, size, sortBy, sortOrder, createdFrom, createdTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpertApi
     */
    public expertStudentsWithProfilesGet(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ExpertApiFp(this.configuration).expertStudentsWithProfilesGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} mediaId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaMediaIdDelete: async (mediaId: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('mediaMediaIdDelete', 'mediaId', mediaId)
            const localVarPath = `/media/{mediaId}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaMediaIdGet: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('mediaMediaIdGet', 'mediaId', mediaId)
            const localVarPath = `/media/{mediaId}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mediaId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaMediaIdPut: async (mediaId: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('mediaMediaIdPut', 'mediaId', mediaId)
            const localVarPath = `/media/{mediaId}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaUploadPost: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} mediaId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaMediaIdDelete(mediaId: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaMediaIdDelete(mediaId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaMediaIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaMediaIdGet(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaMediaIdGet(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaMediaIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} mediaId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaMediaIdPut(mediaId: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaFileMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaMediaIdPut(mediaId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaMediaIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaUploadPost(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaFileMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaUploadPost(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @param {string} mediaId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaMediaIdDelete(mediaId: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.mediaMediaIdDelete(mediaId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaMediaIdGet(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.mediaMediaIdGet(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} mediaId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaMediaIdPut(mediaId: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaFileMeta> {
            return localVarFp.mediaMediaIdPut(mediaId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaUploadPost(userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaFileMeta> {
            return localVarFp.mediaUploadPost(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @param {string} mediaId 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaMediaIdDelete(mediaId: string, userId?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaMediaIdDelete(mediaId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaMediaIdGet(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaMediaIdGet(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} mediaId 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaMediaIdPut(mediaId: string, userId?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaMediaIdPut(mediaId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaUploadPost(userId?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaUploadPost(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles/staff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesStaffIdGet', 'id', id)
            const localVarPath = `/profiles/staff/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffIdPut: async (id: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesStaffIdPut', 'id', id)
            // verify required parameter 'updateStaffProfileRequest' is not null or undefined
            assertParamExists('profilesStaffIdPut', 'updateStaffProfileRequest', updateStaffProfileRequest)
            const localVarPath = `/profiles/staff/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStaffProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStaffProfileRequest} createStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffPost: async (createStaffProfileRequest: CreateStaffProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStaffProfileRequest' is not null or undefined
            assertParamExists('profilesStaffPost', 'createStaffProfileRequest', createStaffProfileRequest)
            const localVarPath = `/profiles/staff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStaffProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffPut: async (updateStaffProfileRequest: UpdateStaffProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStaffProfileRequest' is not null or undefined
            assertParamExists('profilesStaffPut', 'updateStaffProfileRequest', updateStaffProfileRequest)
            const localVarPath = `/profiles/staff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStaffProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesUserIdGet', 'id', id)
            const localVarPath = `/profiles/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserIdPut: async (id: string, updateUserProfileRequest: UpdateUserProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesUserIdPut', 'id', id)
            // verify required parameter 'updateUserProfileRequest' is not null or undefined
            assertParamExists('profilesUserIdPut', 'updateUserProfileRequest', updateUserProfileRequest)
            const localVarPath = `/profiles/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserPost: async (createUserProfileRequest: CreateUserProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserProfileRequest' is not null or undefined
            assertParamExists('profilesUserPost', 'createUserProfileRequest', createUserProfileRequest)
            const localVarPath = `/profiles/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserPut: async (updateUserProfileRequest: UpdateUserProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserProfileRequest' is not null or undefined
            assertParamExists('profilesUserPut', 'updateUserProfileRequest', updateUserProfileRequest)
            const localVarPath = `/profiles/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserLanguageSkillRequest} userLanguageSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserUserLanguageSkillsPost: async (userLanguageSkillRequest: UserLanguageSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLanguageSkillRequest' is not null or undefined
            assertParamExists('profilesUserUserLanguageSkillsPost', 'userLanguageSkillRequest', userLanguageSkillRequest)
            const localVarPath = `/profiles/user/user/language-skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLanguageSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesStaffGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesStaffGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesStaffGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesStaffIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesStaffIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesStaffIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesStaffIdPut(id: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesStaffIdPut(id, updateStaffProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesStaffIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStaffProfileRequest} createStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesStaffPost(createStaffProfileRequest: CreateStaffProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesStaffPost(createStaffProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesStaffPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesStaffPut(updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesStaffPut(updateStaffProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesStaffPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUserGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUserGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUserIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUserIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUserIdPut(id: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUserIdPut(id, updateUserProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUserPost(createUserProfileRequest: CreateUserProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUserPost(createUserProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUserPut(updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUserPut(updateUserProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesUserPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserLanguageSkillRequest} userLanguageSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUserUserLanguageSkillsPost(userLanguageSkillRequest: UserLanguageSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUserUserLanguageSkillsPost(userLanguageSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profilesUserUserLanguageSkillsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffGet(options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.profilesStaffGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.profilesStaffIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffIdPut(id: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.profilesStaffIdPut(id, updateStaffProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStaffProfileRequest} createStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffPost(createStaffProfileRequest: CreateStaffProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.profilesStaffPost(createStaffProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesStaffPut(updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<StaffProfileResponse> {
            return localVarFp.profilesStaffPut(updateStaffProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserGet(options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.profilesUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.profilesUserIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserIdPut(id: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.profilesUserIdPut(id, updateUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserPost(createUserProfileRequest: CreateUserProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.profilesUserPost(createUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserPut(updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.profilesUserPut(updateUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserLanguageSkillRequest} userLanguageSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUserUserLanguageSkillsPost(userLanguageSkillRequest: UserLanguageSkillRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.profilesUserUserLanguageSkillsPost(userLanguageSkillRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesStaffGet(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesStaffGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesStaffIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesStaffIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesStaffIdPut(id: string, updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesStaffIdPut(id, updateStaffProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStaffProfileRequest} createStaffProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesStaffPost(createStaffProfileRequest: CreateStaffProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesStaffPost(createStaffProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateStaffProfileRequest} updateStaffProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesStaffPut(updateStaffProfileRequest: UpdateStaffProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesStaffPut(updateStaffProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesUserGet(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesUserIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesUserIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateUserProfileRequest} updateUserProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesUserIdPut(id: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesUserIdPut(id, updateUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserProfileRequest} createUserProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesUserPost(createUserProfileRequest: CreateUserProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesUserPost(createUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserProfileRequest} updateUserProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesUserPut(updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesUserPut(updateUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLanguageSkillRequest} userLanguageSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profilesUserUserLanguageSkillsPost(userLanguageSkillRequest: UserLanguageSkillRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profilesUserUserLanguageSkillsPost(userLanguageSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudentApi - axios parameter creator
 * @export
 */
export const StudentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Обновить query задачи (PATCH) <br> Получить бейджи пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentBadgesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/student/badges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentBadgesPost: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('studentBadgesPost', 'body', body)
            const localVarPath = `/student/badges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отписаться от курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdEnrollDelete: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('studentCoursesCourseIdEnrollDelete', 'courseId', courseId)
            const localVarPath = `/student/courses/{courseId}/enroll`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Записаться на курс
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdEnrollPost: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('studentCoursesCourseIdEnrollPost', 'courseId', courseId)
            const localVarPath = `/student/courses/{courseId}/enroll`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить прогресс курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdProgressGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('studentCoursesCourseIdProgressGet', 'courseId', courseId)
            const localVarPath = `/student/courses/{courseId}/progress`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdSectionsGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('studentCoursesCourseIdSectionsGet', 'courseId', courseId)
            const localVarPath = `/student/courses/{courseId}/sections`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить темы курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdThemesGet: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('studentCoursesCourseIdThemesGet', 'courseId', courseId)
            const localVarPath = `/student/courses/{courseId}/themes`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить курсы с языком, совпадающим с системным языком пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/student/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить все курсы пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentEnrollmentsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/student/enrollments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить прогресс секции
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentSectionsSectionIdProgressGet: async (sectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('studentSectionsSectionIdProgressGet', 'sectionId', sectionId)
            const localVarPath = `/student/sections/{sectionId}/progress`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить очередь задач пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/student/task-queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить следующую задачу в очереди
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueNextGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/student/task-queue/next`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTaskQueueRequest} createTaskQueueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueuePost: async (createTaskQueueRequest: CreateTaskQueueRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskQueueRequest' is not null or undefined
            assertParamExists('studentTaskQueuePost', 'createTaskQueueRequest', createTaskQueueRequest)
            const localVarPath = `/student/task-queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskQueueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удалить задачу из очереди
         * @param {string} queueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueQueueIdDelete: async (queueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('studentTaskQueueQueueIdDelete', 'queueId', queueId)
            const localVarPath = `/student/task-queue/{queueId}`
                .replace(`{${"queueId"}}`, encodeURIComponent(String(queueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновить позицию задачи в очереди
         * @param {string} queueId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueQueueIdPositionPatch: async (queueId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('studentTaskQueueQueueIdPositionPatch', 'queueId', queueId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('studentTaskQueueQueueIdPositionPatch', 'body', body)
            const localVarPath = `/student/task-queue/{queueId}/position`
                .replace(`{${"queueId"}}`, encodeURIComponent(String(queueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить ответ задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdAnswerGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdAnswerGet', 'taskId', taskId)
            const localVarPath = `/student/tasks/{taskId}/answer`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отметить задачу как выполненную
         * @param {string} taskId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdCompletePost: async (taskId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdCompletePost', 'taskId', taskId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('studentTasksTaskIdCompletePost', 'body', body)
            const localVarPath = `/student/tasks/{taskId}/complete`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить весь контент задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdContentGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdContentGet', 'taskId', taskId)
            const localVarPath = `/student/tasks/{taskId}/content`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить прогресс задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdProgressGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdProgressGet', 'taskId', taskId)
            const localVarPath = `/student/tasks/{taskId}/progress`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновить прогресс задачи
         * @param {string} taskId 
         * @param {UpdateTaskProgressRequest} updateTaskProgressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdProgressPatch: async (taskId: string, updateTaskProgressRequest: UpdateTaskProgressRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdProgressPatch', 'taskId', taskId)
            // verify required parameter 'updateTaskProgressRequest' is not null or undefined
            assertParamExists('studentTasksTaskIdProgressPatch', 'updateTaskProgressRequest', updateTaskProgressRequest)
            const localVarPath = `/student/tasks/{taskId}/progress`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskProgressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создать прогресс задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdProgressPost: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdProgressPost', 'taskId', taskId)
            const localVarPath = `/student/tasks/{taskId}/progress`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить query задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdQueryGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdQueryGet', 'taskId', taskId)
            const localVarPath = `/student/tasks/{taskId}/query`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdReportPost: async (taskId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdReportPost', 'taskId', taskId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('studentTasksTaskIdReportPost', 'body', body)
            const localVarPath = `/student/tasks/{taskId}/report`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить варианты задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdVariantsGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('studentTasksTaskIdVariantsGet', 'taskId', taskId)
            const localVarPath = `/student/tasks/{taskId}/variants`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить задачи темы
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentThemesThemeIdTasksGet: async (themeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('studentThemesThemeIdTasksGet', 'themeId', themeId)
            const localVarPath = `/student/themes/{themeId}/tasks`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentApi - functional programming interface
 * @export
 */
export const StudentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentApiAxiosParamCreator(configuration)
    return {
        /**
         * Обновить query задачи (PATCH) <br> Получить бейджи пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentBadgesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Badge>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentBadgesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentBadgesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentBadgesPost(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentBadgesPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentBadgesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отписаться от курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentCoursesCourseIdEnrollDelete(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentCoursesCourseIdEnrollDelete(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentCoursesCourseIdEnrollDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Записаться на курс
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentCoursesCourseIdEnrollPost(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentCoursesCourseIdEnrollPost(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentCoursesCourseIdEnrollPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить прогресс курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentCoursesCourseIdProgressGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseProgressItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentCoursesCourseIdProgressGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentCoursesCourseIdProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentCoursesCourseIdSectionsGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Section>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentCoursesCourseIdSectionsGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentCoursesCourseIdSectionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить темы курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentCoursesCourseIdThemesGet(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Theme>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentCoursesCourseIdThemesGet(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentCoursesCourseIdThemesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить курсы с языком, совпадающим с системным языком пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentCoursesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentCoursesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentCoursesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить все курсы пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentEnrollmentsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCourseEnrollmentItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentEnrollmentsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentEnrollmentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить прогресс секции
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentSectionsSectionIdProgressGet(sectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionProgressItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentSectionsSectionIdProgressGet(sectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentSectionsSectionIdProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить очередь задач пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTaskQueueGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserTaskQueueItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTaskQueueGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTaskQueueGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить следующую задачу в очереди
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTaskQueueNextGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskQueueItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTaskQueueNextGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTaskQueueNextGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateTaskQueueRequest} createTaskQueueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTaskQueuePost(createTaskQueueRequest: CreateTaskQueueRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskQueueItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTaskQueuePost(createTaskQueueRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTaskQueuePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удалить задачу из очереди
         * @param {string} queueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTaskQueueQueueIdDelete(queueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTaskQueueQueueIdDelete(queueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTaskQueueQueueIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновить позицию задачи в очереди
         * @param {string} queueId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTaskQueueQueueIdPositionPatch(queueId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTaskQueueQueueIdPositionPatch(queueId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTaskQueueQueueIdPositionPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить ответ задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdAnswerGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskAnswerItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdAnswerGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdAnswerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отметить задачу как выполненную
         * @param {string} taskId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdCompletePost(taskId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskProgressItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdCompletePost(taskId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdCompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить весь контент задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdContentGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskContentItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdContentGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdContentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить прогресс задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdProgressGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskProgressItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdProgressGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновить прогресс задачи
         * @param {string} taskId 
         * @param {UpdateTaskProgressRequest} updateTaskProgressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdProgressPatch(taskId: string, updateTaskProgressRequest: UpdateTaskProgressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskProgressItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdProgressPatch(taskId, updateTaskProgressRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdProgressPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создать прогресс задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdProgressPost(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskProgressItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdProgressPost(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdProgressPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить query задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdQueryGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdQueryGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdQueryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdReportPost(taskId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdReportPost(taskId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdReportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить варианты задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentTasksTaskIdVariantsGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskAnswerOptionItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentTasksTaskIdVariantsGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentTasksTaskIdVariantsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить задачи темы
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentThemesThemeIdTasksGet(themeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskWithDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentThemesThemeIdTasksGet(themeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentApi.studentThemesThemeIdTasksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudentApi - factory interface
 * @export
 */
export const StudentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentApiFp(configuration)
    return {
        /**
         * Обновить query задачи (PATCH) <br> Получить бейджи пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentBadgesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Badge>> {
            return localVarFp.studentBadgesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentBadgesPost(body: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.studentBadgesPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Отписаться от курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdEnrollDelete(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.studentCoursesCourseIdEnrollDelete(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Записаться на курс
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdEnrollPost(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.studentCoursesCourseIdEnrollPost(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить прогресс курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdProgressGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseProgressItem> {
            return localVarFp.studentCoursesCourseIdProgressGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdSectionsGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Section>> {
            return localVarFp.studentCoursesCourseIdSectionsGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить темы курса
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesCourseIdThemesGet(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Theme>> {
            return localVarFp.studentCoursesCourseIdThemesGet(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить курсы с языком, совпадающим с системным языком пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentCoursesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Course>> {
            return localVarFp.studentCoursesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить все курсы пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentEnrollmentsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserCourseEnrollmentItem>> {
            return localVarFp.studentEnrollmentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить прогресс секции
         * @param {string} sectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentSectionsSectionIdProgressGet(sectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<SectionProgressItem> {
            return localVarFp.studentSectionsSectionIdProgressGet(sectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить очередь задач пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserTaskQueueItem>> {
            return localVarFp.studentTaskQueueGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить следующую задачу в очереди
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueNextGet(options?: RawAxiosRequestConfig): AxiosPromise<UserTaskQueueItem> {
            return localVarFp.studentTaskQueueNextGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTaskQueueRequest} createTaskQueueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueuePost(createTaskQueueRequest: CreateTaskQueueRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserTaskQueueItem> {
            return localVarFp.studentTaskQueuePost(createTaskQueueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Удалить задачу из очереди
         * @param {string} queueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueQueueIdDelete(queueId: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.studentTaskQueueQueueIdDelete(queueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновить позицию задачи в очереди
         * @param {string} queueId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTaskQueueQueueIdPositionPatch(queueId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.studentTaskQueueQueueIdPositionPatch(queueId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить ответ задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdAnswerGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskAnswerItem> {
            return localVarFp.studentTasksTaskIdAnswerGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Отметить задачу как выполненную
         * @param {string} taskId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdCompletePost(taskId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<UserTaskProgressItem> {
            return localVarFp.studentTasksTaskIdCompletePost(taskId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить весь контент задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdContentGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskContentItem>> {
            return localVarFp.studentTasksTaskIdContentGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить прогресс задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdProgressGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserTaskProgressItem> {
            return localVarFp.studentTasksTaskIdProgressGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновить прогресс задачи
         * @param {string} taskId 
         * @param {UpdateTaskProgressRequest} updateTaskProgressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdProgressPatch(taskId: string, updateTaskProgressRequest: UpdateTaskProgressRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserTaskProgressItem> {
            return localVarFp.studentTasksTaskIdProgressPatch(taskId, updateTaskProgressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Создать прогресс задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdProgressPost(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserTaskProgressItem> {
            return localVarFp.studentTasksTaskIdProgressPost(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить query задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdQueryGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskWithDetails> {
            return localVarFp.studentTasksTaskIdQueryGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdReportPost(taskId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.studentTasksTaskIdReportPost(taskId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить варианты задачи
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentTasksTaskIdVariantsGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskAnswerOptionItem>> {
            return localVarFp.studentTasksTaskIdVariantsGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить задачи темы
         * @param {string} themeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentThemesThemeIdTasksGet(themeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskWithDetails>> {
            return localVarFp.studentThemesThemeIdTasksGet(themeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentApi - object-oriented interface
 * @export
 * @class StudentApi
 * @extends {BaseAPI}
 */
export class StudentApi extends BaseAPI {
    /**
     * Обновить query задачи (PATCH) <br> Получить бейджи пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentBadgesGet(options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentBadgesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentBadgesPost(body: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentBadgesPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отписаться от курса
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentCoursesCourseIdEnrollDelete(courseId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentCoursesCourseIdEnrollDelete(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Записаться на курс
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentCoursesCourseIdEnrollPost(courseId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentCoursesCourseIdEnrollPost(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить прогресс курса
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentCoursesCourseIdProgressGet(courseId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentCoursesCourseIdProgressGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentCoursesCourseIdSectionsGet(courseId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentCoursesCourseIdSectionsGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить темы курса
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentCoursesCourseIdThemesGet(courseId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentCoursesCourseIdThemesGet(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить курсы с языком, совпадающим с системным языком пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentCoursesGet(options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentCoursesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить все курсы пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentEnrollmentsGet(options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentEnrollmentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить прогресс секции
     * @param {string} sectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentSectionsSectionIdProgressGet(sectionId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentSectionsSectionIdProgressGet(sectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить очередь задач пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTaskQueueGet(options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTaskQueueGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить следующую задачу в очереди
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTaskQueueNextGet(options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTaskQueueNextGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTaskQueueRequest} createTaskQueueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTaskQueuePost(createTaskQueueRequest: CreateTaskQueueRequest, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTaskQueuePost(createTaskQueueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удалить задачу из очереди
     * @param {string} queueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTaskQueueQueueIdDelete(queueId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTaskQueueQueueIdDelete(queueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновить позицию задачи в очереди
     * @param {string} queueId 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTaskQueueQueueIdPositionPatch(queueId: string, body: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTaskQueueQueueIdPositionPatch(queueId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить ответ задачи
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdAnswerGet(taskId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdAnswerGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отметить задачу как выполненную
     * @param {string} taskId 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdCompletePost(taskId: string, body: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdCompletePost(taskId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить весь контент задачи
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdContentGet(taskId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdContentGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить прогресс задачи
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdProgressGet(taskId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdProgressGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновить прогресс задачи
     * @param {string} taskId 
     * @param {UpdateTaskProgressRequest} updateTaskProgressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdProgressPatch(taskId: string, updateTaskProgressRequest: UpdateTaskProgressRequest, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdProgressPatch(taskId, updateTaskProgressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создать прогресс задачи
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdProgressPost(taskId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdProgressPost(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить query задачи
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdQueryGet(taskId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdQueryGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdReportPost(taskId: string, body: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdReportPost(taskId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить варианты задачи
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentTasksTaskIdVariantsGet(taskId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentTasksTaskIdVariantsGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить задачи темы
     * @param {string} themeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentApi
     */
    public studentThemesThemeIdTasksGet(themeId: string, options?: RawAxiosRequestConfig) {
        return StudentApiFp(this.configuration).studentThemesThemeIdTasksGet(themeId, options).then((request) => request(this.axios, this.basePath));
    }
}



